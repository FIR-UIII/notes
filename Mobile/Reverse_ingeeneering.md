

### **Методология тестирования безопасности APK-приложений**

**Цель:** Выявление уязвимостей и проблем безопасности в Android-приложениях с помощью комбинации статического (SAST) и динамического (DAST) анализа.

#### **Этап 1: Подготовка и получение артефактов**

1.  **Получение APK-файла:**
    *   **Официальный источник:** Google Play Store (используйте инструменты вроде `gplaycli` или `apkeep` для загрузки, если известно название пакета).
    *   **Прямая передача:** От заказчика или разработчика.
    *   **Сборка из исходного кода:** Если есть доступ, соберите APK самостоятельно с помощью Android Studio.

2.  **Подготовка тестовой среды:**
    *   **Эмулятор:** Android Studio Emulator (x86/x86_64, легкий для сниффинга трафика).
    *   **Реальное устройство (рекомендуется):** Пропатченное/рутированное устройство для более точного анализа поведения. Например, устройство из проекта **Magisk**.
    *   **Операционная система аналитика:** Linux (Kali Linux) или Windows с установленным необходимым инструментарием.

3.  **Декомпиляция и получение исходного кода (Статический анализ):**
    *   **Инструменты:**
        *   **Jadx-GUI:** Лучший декомпилятор для быстрого получения читаемого Java/Kotlin кода.
        *   **APKTool:** Разбирает APK на ресурсы, манифест и скомпилированный код `classes.dex`. Незаменим для анализа манифеста и модификации APK.
        *   **Dex2jar + JD-GUI:** Альтернативный, но устаревший метод.

    *   **Команда:**
      ```bash
      # Получение исходного кода с помощью jadx
      jadx -d ./output_dir application.apk

      # Разбор ресурсов с помощью apktool
      apktool d application.apk -o output_dir
      ```

---

#### **Этап 2: Статический анализ (SAST - Static Application Security Testing)**

Анализ кода и ресурсов без его выполнения.

1.  **Анализ AndroidManifest.xml:**
    *   **Проверка прав доступа (Permissions):** Соответствуют ли запрашиваемые разрешения функционалу приложения? Есть ли избыточные или опасные разрешения (`READ_SMS`, `WRITE_SMS`, `ACCESS_FINE_LOCATION`)?
    *   **Экспортируемые компоненты:** Проверьте атрибуты `android:exported` для Activity, Service, Broadcast Receiver и Content Provider. Непреднамеренно экспортируемые компоненты — частая причина уязвимостей.
    *   **Debuggable:** Установлен ли флаг `android:debuggable="true"` в релизной сборке?
    *   **Network Security Configuration:** Проверьте `android:networkSecurityConfig`. Разрешает ли приложение использовать самоподписанные сертификаты или трафик через HTTP?

2.  **Анализ исходного кода (Java/Kotlin):**
    *   **Уязвимости ввода данных (Injection):** Поиск использования `SQLiteDatabase.execSQL()`, `RawQuery()` (SQL Injection), невалидируемый ввод для командной строки.
    *   **Небезопасное хранение данных:** Поиск в коде жестко закодированных (hardcoded) ключей, паролей, токенов. Анализ использования `SharedPreferences`, внутреннего хранилища, базы данных.
    *   **Небезопасная криптография:** Использование устаревших алгоритмов (DES, MD5, SHA1), неправильная реализация AES (например, статический IV), использование собственных криптоалгоритмов.
    *   **Небезопасная десериализация:** Использование `ObjectInputStream` без валидации входящих данных.
    *   **Межпроцессное взаимодействие (IPC):** Проверка компонентов, получающих данные извне. Включена ли проверка (`checkCallingPermission`)? Правильно ли реализованы `Parcelable` объекты?
    *   **ВебВью:** Проверка `WebView` на включенный JavaScript (`setJavaScriptEnabled`), особенно если он загружает внешний контент. Проверка на уязвимости типа **JS-Bridge Injection** (`addJavascriptInterface`).

3.  **Анализ нативных библиотек (C/C++):**
    *   **Использование инструментов:** **Ghidra**, **IDA Pro**, **radare2**.
    *   **Бинарные уязвимости:** Переполнение буфера, форматная строка (format string), использование небезопасных функций (`strcpy`, `sprintf`).

4.  **Автоматизированное сканирование:**
    *   **MobSF (Mobile Security Framework):** Лучший инструмент с открытым исходным кодом. Автоматически проводит статический анализ, показывает уровень риска и предоставляет подробный отчет.
    *   **QARK (Quick Android Review Kit):** Еще один инструмент от LinkedIn для поиска уязвимостей.
    *   **SonarQube** + **Plugins:** Для интеграции в CI/CD.

---

#### **Этап 3: Динамический анализ (DAST - Dynamic Application Security Testing)**

Анализ приложения во время его выполнения.

1.  **Настройка среды для тестирования:**
    *   **Прокси-сервер:** Настройте устройство/эмулятор для работы через прокси (например, **Burp Suite** или **OWASP ZAP**).
    *   **Обход SSL Pinning:**
        *   **Инструменты:** **Frida**, **Objection** (`android sslpinning disable`), **Magisk** + модуль **MagiskTrustUserCerts**.
        *   **Цель:** Перехватить и проанализировать зашифрованный HTTPS-трафик.
    *   **Патчинг APK:** Если Frida не работает, используйте `apktool` для декомпиляции, патча файла `AndroidManifest.xml` (добавление `android:debuggable="true"`) и повторной сборки APK с подписью.

2.  **Тестирование на стороне клиента:**
    *   **Анализ трафика:** Перехват всех запросов в Burp Suite. Поиск уязвимостей на стороне сервера (SQLi, XSS, IDOR) через мобильное приложение.
    *   **Тестирование хранилища:** Проверьте файлы приложения в `/data/data/[package_name]/` (требуется root-доступ). Убедитесь, что чувствительные данные (токены, PIN) не хранятся в открытом виде в `SharedPreferences`, базах данных или файлах.
    *   **Логирование (Logging):** Используйте `logcat` для поиска утечек чувствительной информации через логи (`Log.d`, `Log.e`).
    *   **Анализ процессов:** Используйте **Frida** для хукинга (hook) методов в runtime, чтобы обойти проверки, изменить логику или извлечь ключи из памяти. **Objection** как CLI-надстройка над Frida.
    *   **Тестирование на глубину ссылок (Deep Links):** Попытка запуска экспортируемых Activity через Intent или ADB для выявления недоступных функциональностей.
    *   **Вставка в WebView:** Если в приложении есть WebView, используйте инструменты разработчика Chrome (`chrome://inspect`) для отладки и тестирования веб-контента на уязвимости.

3.  **Автоматизированное динамическое сканирование:**
    *   **MobSF:** Имеет встроенный динамический анализатор.
    *   **QARK:** Может проводить некоторые динамические тесты.
    *   **AppMon:** Инструмент для автоматического хукинга и мониторинга API.

---

#### **Этап 4: Постобработка и отчетность**

1.  **Верификация находок:** Не все, что находит автоматический сканер, является истинной уязвимостью. Всегда вручную проверяйте и подтверждайте каждую находку.
2.  **Оценка риска:** Оцените критичность каждой уязвимости по модели **CVSS** или аналогичной.
3.  **Составление отчета:**
    *   **Executive Summary:** Краткое описание для руководства.
    *   **Детальная техническая часть:** Для разработчиков.
        *   Название уязвимости.
        *   **CVSS Score** и уровень риска (Critical, High, Medium, Low).
        *   **Описание** проблемы.
        *   **Шаги воспроизведения** (Proof-of-Concept).
        *   **Локация** в коде (для SAST) или сценарий (для DAST).
        *   **Воздействие** на безопасность.
        *   **Рекомендации** по исправлению.
    *   **Приложения:** Скриншоты, логи, сниппеты кода.

---

### **Чеклист для быстрого старта:**

1.  [ ] Получить APK (`adb install` или из магазина)
2.  [ ] Декомпилировать с помощью `jadx-gui`
3.  [ ] Проанализировать `AndroidManifest.xml`
4.  [ ] Запустить автоматическое сканирование в **MobSF**
5.  [ ] Настроить устройство на прокси (**Burp Suite**)
6.  [ ] Обойти SSL Pinning с помощью **Frida**/**Objection**
7.  [ ] Проанализировать весь трафик приложения
8.  [ ] Исследовать файловую систему приложения (root)
9.  [ ] Проанализировать логи `logcat`
10. [ ] Использовать **Frida** для хукинга критических методов
11. [ ] Составить отчет, верифицировав все автоматические находки

Данная методология является итеративной и цикличной. Обнаружение одной уязвимости часто приводит к необходимости более глубокого анализа смежных компонентов приложения.