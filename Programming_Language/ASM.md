MASM32 v11 download: https://masm32.com/download.htm
RadAsm IDE: http://www.assembly.com.br/
WinAsm Studio IDE: https://winasm.org/index.html
Online: https://www.tutorialspoint.com/compile_assembly_online.php 
        https://carlosrafaelgn.com.br/Asm86/
        https://yjdoc2.github.io/8086-emulator-web/compile 
        
Онлайн компилятор в ASM из вернеуровнего ЯП: https://godbolt.org/

### Общее
| Level               |  Language             | Code                  |
| --------------------| --------------------  | --------------------  |
| High-level language | C++                   | sum = 5;              |
| Asssembly           | GNU Assembler         | movl $0x5, -0x8(%ebp) |
| Machine language    | IA-32                 | C745F805000000        |
| Digital logic       | Binary                | 1100 0111 0100 0101 1111 1000 0000 0101 0000 0000 0000 0000 0000 0000 |

### Синтаксис и Типы ассемблеров ASM
Есть два синтаксиса AT&T - UNIX, Intel - MASM Windows
Для каждой архитектуры процессовров свой асм. Нет кроссплатформенность но есть обратная совместимость для семейства архитектуры



Address: 0xffff0000
Word: \xAA\xBB\xCC\xDD

| GAS \\ GCC | MASM  | NASM | ARM64 |
| --------- | ---------- | ------- | ----------- |
| .data<br>.globl greet<br>greet:<br>.string "Hello world!"<br>.text<br>.global main<br>main:<br>pushq %rbp<br>movq %rsp, %rbp| .686<br>.model small<br>.stack 100h<br>.data<br>msg db 'Hello world!$'<br>.code<br>start:<br>mov ah, 09h ; Display the message<br>lea dx, msg<br>int 21h | section .data<br>msg db "Hello world!", 0ah<br>section .text<br>global \_start<br>_start:<br>mov rax, 1  | .global \_start // устанавливаем стартовый адрес программы<br>_start: mov X0, #1 // 1 = StdOut - поток вывода<br>ldr X1, =hello // строка для вывода на экран<br>mov X2, #19 // длина строки |
| GNU Assembler или сокращенно GAS. Он поставляется как компонент набора компиляторов GCC.<br>GAS использует синтаксис, отличный от синтаксиса Intel (а именно синтаксис AT&T)<br>https://metanit.com/assembler/gas/1.4.php<br>https://www.onlinegdb.com/online_gcc_assembler<br>https://godbolt.org/<br>[https://www.jdoodle.com/compile-assembler-gcc-online](https://www.jdoodle.com/compile-assembler-gcc-online) | Преимуществом MASM является то, что MASM использует для своих инструкций синтаксис Intel. Недостатком MASM является наличие официальной поддержки только для ОС Windows. | Netwide Assembler или NASM развивается как opensource-проект и использует синтаксис, который похож на синтаксис Intel. Является кросс-платформенным и работает почти на любой платформе.<br>https://www.mycompiler.io/new/asm-x86_64<br>https://onecompiler.com/assembly/ | iOS и Android, Raspberry Pi. |

### Архитектуры
x86. Процессоры 8086 и 8088 были 16-битными, несмотря на 8-битную шину данных в 8088. Регистры в этих процессорах имели разрядность 16 бит, а набор инструкций работал с 16-битными данными. <br>

х64

х32

х16

### Создание программы
Для выполнения используются инструкции ISA. Связующее звено между железом и софтом
Компилятор > АСМ код > Ассемблер > Объектный код мнемоники
Линкер связывает объекты между собой в исполняемый файл (.exe)
Загрузчик загружает исполняемый файл в память CPU
Нет функций, циклов, ООП и проч.

# Основные понятия
1. Разрядность - размер регистров и машинного слова (16-бит реальных адресов, 32-бит защищенный режим, 86-бит long mode)
2. Регистры - ячейки памяти в ЦП для хранения данных. Несмотря на специализацию, все регистры можно использовать в любых машинных операциях. Однако надо учитывать тот факт, что некоторые команды работают только с определёнными регистрами. Например, команды умножения и деления используют регистры EAX и EDX для хранения исходных данных и результата операции. Команды управления циклом используют регистр ECX в качестве счётчика циклах. Ещё один нюанс состоит в использовании регистров в качестве базы, т.е. хранилища адреса оперативной памяти. В качестве регистров базы можно использовать любые регистры, но желательно использовать регистры EBX, ESI, EDI или EBP. В этом случае размер машинной команды обычно бывает меньше. <br>

4   / 2  / 1  / 1  - byte(s)<br>
32  / 16 / 8  / 8  - bits<br>
EAX / AX / AH / AL (accumulator register) – аккумулятор;<br>
EBX / BX / BH / BL (base register) – регистр базы;<br>
ECX / CX / CH / CL (counter register) – счётчик;<br>
EDX / DX / DH / DL (data register) – регистр данных;<br>
ESI / SI (source index register) – индекс источника;<br>
EDI / DI (destination index register) – индекс приёмника (получателя);<br>

EIP / IP Instruction Pointer stores the offset address of the next instruction to be executed;<br>
ESP / SP (stack pointer register) – регистр указателя стека;<br>
EBP / BP (stack base pointer or frame pointer) – регистр указателя базы кадра стека.<br>

При выборе регистра важно учитывать размер принимаемых значений!<br>
Так, CL - 8-разрядный и может принимать только 8-разрядные числа. Максимальное 8-разрядное положительное число - 255. Т.е. 256 в регистр не войдет и возникнет ошибка warning: byte data exceeds bounds [-w+number-overflow]<br>

3. Сегменты - при работе программы делиться на сегменты (сегмент кода CS, сегмент данных DS, сегмент стека SS). В зависимости от разрядности размер меняется для 16-битных макс. размер 64Кб, 16 байт минимально. Внутри сегмента пишется код асма. Сегменты можно группировать
  DS: var # DS - сегмент, var - смещение
  0x0051:0x0000 (по 16 бит)
4. Модель памяти. Сегменты присваиваются пространству в памяти (ОЗУ) 
  FLAT x86 - один сегмент
4. Соглашение о вызовах - 
5. Секции - разделы программы по обрабатываемых задачам

### СТЭК RAM
Участок оперативной памяти для быстрой передачи данных. Используется паттерны - LIFO \ FIFO. Принцип хранения данных - обойма магазина.
Реализован как блок памяти ОЗУ / RAM + регистр-указатель SP (ESP, RSP), который указывает на адрес в ячейке памяти.
Стэк формируется от большего адреса в памяти к меньшему.
PUSH уменьшает регистр-указатель, а POP — увеличивает.
Стэк в асме формируется в сегменте .data
```
   0x0000054d <+0>:	    push   ebp       # <---- 1. Stores previous EBP
   0x0000054e <+1>:	    mov    ebp,esp   # <---- 2. Creates new Stack Frame
   0x00000550 <+3>:	    push   ebx
   0x00000551 <+4>:	    sub    esp,0x404 # <---- 3. Moves ESP to the top
   <...SNIP...>
   0x00000580 <+51>:	leave  # <----------------------
   0x00000581 <+52>:	ret    # <--- Leave stack frame
```
Зачем нужен стэк: "долгосрочное" хранение данных на протяжении выполнении кода. Передача аргументов между функциями

### КУЧА RAM
Участок оперативной памяти для данных большого объема. 

##### Глобальные переменные
```
; Можно передавать данные через глобальные переменные. Находятся в секции .data. Глобальные переменные считаются антипаттерном.
; x объявлена в сегменте _DATA
; глобальные переменные обнуляются в начале работы другой программы
_DATA   SEGMENT
COMM    x:DWORD
_DATA   ENDS
; недостаток: такой способ не защищен от рекурсии. не безопасный для мультитредовой среды (когда регистр может быть использован другим потоком)
```

##### Локальные переменные
```
; Находятся вне секции .data
_x$ = 32
```

### ФУНКЦИИ
Пролог функции это инструкции в самом начале функции. 
```
main    PROC       ; начало функции f
push    ebp        ; формирует стэк (область памяти) и сохраняет значение регистра EBP 
mov     ebp, esp   ; выставляет EBP равным ESP
  mov   x, 0		   ; 0 может иметь любой размер, в данном случае берётся 1 байт
  mov   eax, 0		 ; 0 может иметь любой размер, в данном случае берётся 4 байта
  mov   al, 1000h  ; Ошибка – попытка записать 2-байтное число в 1-байтный регистр
  mov   eax, cx		 ; Ошибка – размеры операндов не совпадают
  mov   [ebx], 0	 ; Ошибка, т.к. 0 может иметь любой размер
  mov   byte ptr [ebx], 0 	; Пересылаем 1 байт
  mov   dword ptr [ebx], 0 	; Пересылаем 4 байта
sub     esp, X     ;  место в стеке для хранения локальных переменных
```
Эпилог функции аннулирует выделенное место в стеке и завершает работу функции
```
mov    esp, ebp   ; восстанавливает значение EBP на старое
pop    ebp        ; освобождает стэк
ret    0          ; возвращает 0 функция всегда должна что то вернуть
main    ENDP      ; конец функции f
```
