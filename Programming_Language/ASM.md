MASM32 v11 download: https://masm32.com/download.htm
RadAsm IDE: http://www.assembly.com.br/
WinAsm Studio IDE: https://winasm.org/index.html
Online: https://www.tutorialspoint.com/compile_assembly_online.php 
        https://carlosrafaelgn.com.br/Asm86/
        https://yjdoc2.github.io/8086-emulator-web/compile 
        
Онлайн компилятор в ASM из вернеуровнего ЯП: https://godbolt.org/

### Общее
| Level               |  Language             | Code                  |
| --------------------| --------------------  | --------------------  |
| High-level language | C++                   | sum = 5;              |
| Asssembly           | GNU Assembler         | movl $0x5, -0x8(%ebp) |
| Machine language    | IA-32                 | C745F805000000        |
| Digital logic       | Binary                | 1100 0111 0100 0101 1111 1000 0000 0101 0000 0000 0000 0000 0000 0000 |

### Синтаксис и Типы ассемблеров ASM
Есть два синтаксиса AT&T - UNIX, Intel - MASM Windows
Для каждой архитектуры процессовров свой асм. Нет кроссплатформенность но есть обратная совместимость для семейства архитектуры

##### GAS \ GCC
GNU Assembler или сокращенно GAS. Он поставляется как компонент набора компиляторов GCC.
GAS использует синтаксис, отличный от синтаксиса Intel (а именно синтаксис AT&T)
https://metanit.com/assembler/gas/1.4.php 
https://www.onlinegdb.com/online_gcc_assembler
https://godbolt.org/
https://www.jdoodle.com/compile-assembler-gcc-online

/usr/bin/as
```
.data
.globl greet
greet:
.string "Hello world!"
.text
.global main
main:
    pushq   %rbp
    movq    %rsp,       %rbp
```

##### MASM
Преимуществом MASM является то, что MASM использует для своих инструкций синтаксис Intel. Недостатком MASM является наличие официальной поддержки только для ОС Windows.
No online
```
.686
.model small
.stack 100h
.data
msg	db	'Hello world!$'
.code
start:
	mov	ah, 09h   ; Display the message
	lea	dx, msg
	int	21h
```

##### NASM
Netwide Assembler или NASM развивается как opensource-проект и использует синтаксис, который похож на синтаксис Intel. Является кросс-платформенным и работает почти на любой платформе.
https://www.mycompiler.io/new/asm-x86_64 
https://onecompiler.com/assembly/ 
```
section .data
    msg db "Hello world!", 0ah
section .text
    global _start
_start:
    mov rax, 1
```

### ARM64
iOS и Android, Raspberry Pi.
```
.global _start          // устанавливаем стартовый адрес программы
_start: mov X0, #1          // 1 = StdOut - поток вывода
 ldr X1, =hello             // строка для вывода на экран
 mov X2, #19                // длина строки
```

### Архитектуры
x86. Процессоры 8086 и 8088 были 16-битными, несмотря на 8-битную шину данных в 8088. Регистры в этих процессорах имели разрядность 16 бит, а набор инструкций работал с 16-битными данными. <br>

х64

х32

х16

### Создание программы
Для выполнения используются инструкции ISA. Связующее звено между железом и софтом
Компилятор > АСМ код > Ассемблер > Объектный код мнемоники
Линкер связывает объекты между собой в исполняемый файл (.exe)
Загрузчик загружает исполняемый файл в память CPU
Нет функций, циклов, ООП и проч.

# Основные понятия
1. Разрядность - размер регистров и машинного слова (16-бит реальных адресов, 32-бит защищенный режим, 86-бит long mode)
2. Регистры - ячейки памяти в ЦП для хранения данных. Несмотря на специализацию, все регистры можно использовать в любых машинных операциях. Однако надо учитывать тот факт, что некоторые команды работают только с определёнными регистрами. Например, команды умножения и деления используют регистры EAX и EDX для хранения исходных данных и результата операции. Команды управления циклом используют регистр ECX в качестве счётчика циклах. Ещё один нюанс состоит в использовании регистров в качестве базы, т.е. хранилища адреса оперативной памяти. В качестве регистров базы можно использовать любые регистры, но желательно использовать регистры EBX, ESI, EDI или EBP. В этом случае размер машинной команды обычно бывает меньше. <br>

4   / 2  / 1  / 1  - byte(s)<br>
32  / 16 / 8  / 8  - bits<br>
EAX / AX / AH / AL (accumulator register) – аккумулятор;<br>
EBX / BX / BH / BL (base register) – регистр базы;<br>
ECX / CX / CH / CL (counter register) – счётчик;<br>
EDX / DX / DH / DL (data register) – регистр данных;<br>
ESI / SI (source index register) – индекс источника;<br>
EDI / DI (destination index register) – индекс приёмника (получателя);<br>
ESP / SP (stack pointer register) – регистр указателя стека;<br>
EBP / BP (base pointer register) – регистр указателя базы кадра стека.<br>

При выборе регистра важно учитывать размер принимаемых значений!<br>
Так, CL - 8-разрядный и может принимать только 8-разрядные числа. Максимальное 8-разрядное положительное число - 255. Т.е. 256 в регистр не войдет и возникнет ошибка warning: byte data exceeds bounds [-w+number-overflow]<br>

3. Сегменты - при работе программы делиться на сегменты (сегмент кода CS, сегмент данных DS, сегмент стека SS). В зависимости от разрядности размер меняется для 16-битных макс. размер 64Кб, 16 байт минимально. Внутри сегмента пишется код асма. Сегменты можно группировать
  DS: var # DS - сегмент, var - смещение
  0x0051:0x0000 (по 16 бит)
4. Модель памяти. Сегменты присваиваются пространству в памяти (ОЗУ) 
  FLAT x86 - один сегмент
4. Соглашение о вызовах - 
5. Секции - разделы программы по обрабатываемых задачам

### СТЭК RAM
Участок оперативной памяти для быстрой передачи данных. Используется паттерны - LIFO \ FIFO. Принцип хранения данных - обойма магазина.
Реализован как блок памяти ОЗУ / RAM + регистр-указатель SP (ESP, RSP), который указывает на адрес в ячейке памяти.
PUSH уменьшает регистр-указатель, а POP — увеличивает.
```
.data ; формирование стека
Stack Bottom  dd 0
              ...
              dd 0
StackTop      dd 0 ; вершина стека по принципу LIFO
StackPointer  dd offset StackTop ; определение укателя стека для дальнейшей работы с ним

_start:
  mov ebp,StackPointer

  ; имитация команды PUSH наполнение
  sub ebp,4 ; резервируем память для добавления данных
  mov dword ptr[ebp],1 ; добавляем данные в стек

  ; ИЛИ тоже самое вместо sub и mov
  push 1
  pop 1
```
Зачем нужен стэк: "долгосрочное" хранение данных на протяжении выполнении кода. Передача аргументов между функциями

### КУЧА RAM
Участок оперативной памяти для данных большого объема. 

##### Глобальные переменные
```
; Можно передавать данные через глобальные переменные. Находятся в секции .data. Глобальные переменные считаются антипаттерном.
; x объявлена в сегменте _DATA
; глобальные переменные обнуляются в начале работы другой программы
_DATA   SEGMENT
COMM    x:DWORD
_DATA   ENDS
; недостаток: такой способ не защищен от рекурсии. не безопасный для мультитредовой среды (когда регистр может быть использован другим потоком)
```

##### Локальные переменные
```
; Находятся вне секции .data
_x$ = 32
```

### ФУНКЦИИ
Пролог функции это инструкции в самом начале функции. 
```
main    PROC       ; начало функции f
push    ebp        ; формирует стэк (область памяти) и сохраняет значение регистра EBP 
mov     ebp, esp   ; выставляет EBP равным ESP
  mov   x, 0		   ; 0 может иметь любой размер, в данном случае берётся 1 байт
  mov   eax, 0		 ; 0 может иметь любой размер, в данном случае берётся 4 байта
  mov   al, 1000h  ; Ошибка – попытка записать 2-байтное число в 1-байтный регистр
  mov   eax, cx		 ; Ошибка – размеры операндов не совпадают
  mov   [ebx], 0	 ; Ошибка, т.к. 0 может иметь любой размер
  mov   byte ptr [ebx], 0 	; Пересылаем 1 байт
  mov   dword ptr [ebx], 0 	; Пересылаем 4 байта
sub     esp, X     ;  место в стеке для хранения локальных переменных
```
Эпилог функции аннулирует выделенное место в стеке и завершает работу функции
```
mov    esp, ebp   ; восстанавливает значение EBP на старое
pop    ebp        ; освобождает стэк
ret    0          ; возвращает 0 функция всегда должна что то вернуть
main    ENDP      ; конец функции f
```
